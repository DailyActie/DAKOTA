Blurb::
Evolutionary Algorithm
Description::
SCOLIB (formerly known as COLINY) is a collection of nongradient-based
optimizers that support the Common Optimization Library INterface
(COLIN). SCOLIB optimizers currently include \c coliny_cobyla, \c
coliny_direct, \c coliny_ea, \c coliny_pattern_search and \c
coliny_solis_wets. (Yes, the input spec still has "coliny" prepended
to the method name.) Additional SCOLIB information is available from
https://software.sandia.gov/trac/acro.

SCOLIB solvers now support bound constraints and general nonlinear
constraints. Supported nonlinear constraints include both equality
and two-sided inequality constraints. SCOLIB solvers do not yet
support linear constraints. Most SCOLIB optimizers treat constraints
with a simple penalty scheme that adds \c constraint_penalty times the
sum of squares of the constraint violations to the objective function.
Specific exceptions to this method for handling constraint violations
are noted below. (The default value of \c constraint_penalty is
1000.0, except for methods that dynamically adapt their constraint
penalty, for which the default value is 1.0.)

The method independent controls for \c max_iterations and \c
max_function_evaluations limit the number of major iterations and the
number of function evaluations that can be performed during a SCOLIB
optimization, respectively. The \c convergence_tolerance control
defines the threshold value on relative change in the objective
function that indicates convergence. The \c output verbosity
specification controls the amount of information generated by SCOLIB:
the \c silent, \c quiet, and \c normal settings correspond to minimal
reporting from SCOLIB, whereas the \c verbose setting corresponds to a
higher level of information, and \c debug outputs method
initialization and a variety of internal SCOLIB diagnostics. The
majority of SCOLIB's methods perform independent function evaluations
that can directly take advantage of %Dakota's parallel
capabilities. Only \c coliny_solis_wets, \c coliny_cobyla, and certain
configurations of \c coliny_pattern_search are inherently serial (see
\ref MethodSCOLIBPS). The parallel methods automatically utilize
parallel logic when the %Dakota configuration supports
parallelism. Lastly, neither \c speculative gradients nor linear
constraints are currently supported with SCOLIB. Specification detail
for method independent controls is provided in Tables \ref T5d1 "5.1"
through \ref T5d3 "5.3".

Some SCOLIB methods exploit parallelism through the use of %Dakota's
concurrent function evaluations. The nature of the algorithms,
however, limits the amount of concurrency that can be exploited. The
maximum amount of evaluation concurrency that can be leveraged by the
various methods is as follows:

\li COBYLA: one
\li DIRECT: twice the number of variables
\li Evolutionary Algorithms: size of the population
\li Pattern Search: size of the search pattern
\li Solis-Wets: one

All SCOLIB methods support the \c show_misc_options optional
specification which results in a dump of all the allowable method
inputs. Note that the information provided by this command refers to
optimizer parameters that are internal to SCOLIB, and which may differ
from corresponding parameters used by the %Dakota interface. The \c
misc_options optional specification provides a means for inputing
additional settings supported by the SCOLIB methods but which are not
currently mapped through the %Dakota input specification. Care must be
taken in using this specification; they should only be employed by
users familiar with the full range of parameter specifications
available directly from SCOLIB and understand any differences that
exist between those specifications and the ones available through
%Dakota.

Each of the SCOLIB methods supports the \c solution_target control,
which defines a convergence criterion in which the optimizer will
terminate if it finds an objective function value lower than the
specified target. 

%Dakota currently provides several variants of evolutionary algorithms,
invoked through the \c coliny_ea group specification.

The basic steps of an evolutionary algorithm are depicted in Figure
5.2.

\image html ga.jpg "Figure 5.2 Depiction of evolutionary algorithm"
\image latex ga.eps "Depiction of evolutionary algorithm" width=10cm

They can be enumerated as follows:
<ol>
<li> Select an initial population randomly and perform function 
evaluations on these individuals
<li> Perform selection for parents based on relative fitness
<li> Apply crossover and mutation to generate \c 
new_solutions_generated new individuals from the selected parents
   <ul>
   <li> Apply crossover with a fixed probability from two 
   selected parents
   <li> If crossover is applied, apply mutation to the newly 
   generated individual with a fixed probability
   <li> If crossover is not applied, apply mutation with a fixed
   probability to a single selected parent
   </ul>
<li> Perform function evaluations on the new individuals
<li> Perform replacement to determine the new population
<li> Return to step 2 and continue the algorithm until convergence
criteria are satisfied or iteration limits are exceeded
</ol>

The random \c seed control provides a mechanism for making a
stochastic optimization repeatable. That is, the use of the same
random seed in identical studies will generate identical results. The
\c population_size control specifies how many individuals will
comprise the EA's population. 

The \c initialization_type defines the type of initialization for the
population of the EA. There are three types: \c simple_random, \c
unique_random, and \c flat_file. \c simple_random creates initial
solutions with random variable values according to a uniform random
number distribution. It gives no consideration to any previously
generated designs. The number of designs is specified by the \c
population_size. \c unique_random is the same as \c simple_random,
except that when a new solution is generated, it is checked against
the rest of the solutions. If it duplicates any of them, it is
rejected. \c flat_file allows the initial population to be read from
a flat file. If \c flat_file is specified, a file name must be given.

The \c fitness_type controls how strongly differences in "fitness"
(i.e., the objective function) are weighted in the process of
selecting "parents" for crossover:

\li the \c linear_rank setting uses a linear scaling of probability of
selection based on the rank order of each individual's objective
function within the population

\li the \c merit_function setting uses a proportional scaling of
probability of selection based on the relative value of each
individual's objective function within the population

The \c replacement_type controls how current populations and newly
generated individuals are combined to create a new population. Each
of the \c replacement_type selections accepts an integer value, which
is referred to below and in \ref T5d12 "Table 5.12" as the \c
replacement_size:

\li The \c random setting creates a new population using
(a) \c replacement_size randomly selected individuals from the current
population, and (b) \c population_size - \c replacement_size
individuals randomly selected from among the newly generated
individuals (the number of which is optionally specified using \c
new_solutions_generated) that are created for each generation (using
the selection, crossover, and mutation procedures).

\li The \c chc setting creates a new population using (a) the \c
replacement_size best individuals from the \e combination of the
current population and the newly generated individuals, and (b) \c
population_size - \c replacement_size individuals randomly selected
from among the remaining individuals in this combined pool. The \c
chc setting is the preferred selection for many engineering problems.

\li The \c elitist (default) setting creates a new population using
(a) the \c replacement_size best individuals from the current
population, (b) and \c population_size - \c replacement_size
individuals randomly selected from the newly generated individuals.
It is possible in this case to lose a good solution from the newly
generated individuals if it is not randomly selected for replacement;
however, the default \c new_solutions_generated value is set such that
the entire set of newly generated individuals will be selected for
replacement.

Note that \c new_solutions_generated is not recognized by %Dakota as a
valid keyword unless \c replacement_type has been specified.



Topics::	package_scolib, package_coliny, evolutionary_algorithm, not_yet_reviewed
Examples::
Theory::
Faq::
See_Also::	method-coliny_beta, method-coliny_direct, method-coliny_pattern_search, method-coliny_cobyla, method-coliny_solis_wets
