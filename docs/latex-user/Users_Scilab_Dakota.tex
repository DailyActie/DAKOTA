\section{Scilab Script and Direct Interfaces}\label{scilab}

Scilab is open source computation software which can be used to
perform function evaluations during Dakota studies, for example to
calculate the objective function in optimization.  Dakota includes
three Scilab interface variants: scripted, linked, and compiled.  In
each mode, Dakota calls Scilab to perform a function evaluation and
then retrieves the Scilab results.  Dakota's Scilab interface was
contributed in 2011 by Yann Collette and Yann Chapalain.  The
Dakota/Scilab interface variants are described next.

\subsection{Scilab Script Interface} 

Dakota distributions include a directory
\texttt{examples/script\_interfaces/Scilab} which demonstrates
script-based interfacing to Scilab.  The {\tt Rosenbrock} subdirectory
contains four notable files:
\begin{itemize}
  \item \texttt{dakota\_scilab\_rosenbrock.in} (the Dakota input file),
  \item \texttt{rosenbrock.sci} (the Scilab computation code),
  \item \texttt{scilab\_rosen\_bb\_simulator.sh} (the analysis driver), and
  \item \texttt{scilab\_rosen\_wrapper.sci} (Scilab script).
\end{itemize}

The \texttt{dakota\_scilab\_rosenbrock.in} file specifies the Dakota
study to perform.  The interface type is external ({\tt fork}) and the
shell script \texttt{scilab\_rosen\_bb\_simulator.sh} is the analysis
driver used to perform function evaluations.

The Scilab file \texttt{rosenbrock.sci} accepts variable values and
computes the objective, gradient, and Hessian values of the Rosenbrock
function as requested by Dakota.

The \texttt{scilab\_rosen\_bb\_simulator.sh} is a short shell driver
script, like that described in Section~\ref{advint:building}, that
Dakota executes to perform each function evaluation. Dakota passes
the names of the parameters and results files to this script as
\texttt{\$argv[1]} and \texttt{\$argv[2]}, respectively. The
\texttt{scilab\_rosen\_bb\_simulator.sh} is divided into three parts:
pre-processing, analysis, and post-processing.

In the analysis portion, the \texttt{scilab\_rosen\_bb\_simulator.sh}
uses \texttt{scilab\_rosen\_wrapper.sci} to extract the current
variable values from the input parameters file (\texttt{\$argv[1]})
and communicate them to the computation code in
\texttt{rosenbrock.sci}.  The resulting objective function is
transmitted to Dakota via the output result file (\texttt{\$argv[1]}),
and the driver script cleans up any temporary files.

The directory also includes PID and FemTRUSS examples, which are run
in a similar way.

\subsection{Scilab Linked Interface} 

The Dakota/Scilab linked interface allows Dakota to communicate
directly with Scilab through in-memory data structures, typically
resulting in faster communication, as it does not rely on files or
pipes.  In this mode, Dakota publishes a data structure into the
Scilab workspace, and then invokes the specified Scilab
analysis\_driver directly.  In Scilab, this structure is an mlist
(\url{http://help.scilab.org/docs/5.3.2/en\_US/mlist.html}), with the same
fields as in the Matlab interface~\ref{advint:figure:matlabparams},
with the addition of a field {\tt dakota\_type}, which is used to validate
the names of fields in the data structure.

The linked interface is implemented in source files {\tt
  src/ScilabInterface.[CH]} directory, and must be enabled at compile
time when building Dakota from source by setting {\tt
  DAKOTA\_SCILAB:BOOL=ON}, and setting appropriate environment
variables at compile and run time as described in {\tt README.Scilab}
in \\ {\tt examples/linked\_interfaces/Scilab/}.  This directory also
contains examples for the Rosenbrock and PID problems.

These examples are similar to those in {\tt script\_interfaces}, with
a few notable exceptions:
\begin{enumerate}
\item There is no shell driver script
\item The Dakota input file specifies the interface as 'scilab',
  indicating a direct, internal interface to Scilab using the Dakota
  data structure described above:
\begin{small}
\begin{verbatim}
interface,
  scilab
    analysis_driver = 'rosenbrock.sci'
\end{verbatim} 
\end{small}
\end{enumerate}


\subsection{Scilab Compiled Interface} 

In ``compiled interface'' mode, the Dakota analysis driver is a
lightweight shim, which communicates with the running application code
such as Scilab via named pipes.  It is similar to that for Matlab in
\texttt{examples/compiled\_interfaces/Matlab}, whose README is likely
instructive.  An example of a Scilab compiled interface is included in \\
\texttt{examples/compiled\_interfaces/Scilab/Rosenbrock}.

As with the other Scilab examples, there are computation code and
Dakota input files.  Note the difference in the Dakota input file
\texttt{rosenbrock.in}, where the analysis driver starts the dakscilab
shim program and always evaluates functions, gradients, and Hessians.

\begin{small}
\begin{verbatim}
interface,
  fork
    analysis_driver = '../dakscilab -d -fp "exec fp.sci" -fpp "exec fpp.sci"'
    parameters_file = 'r.in'
    results_file = 'r.out'
    deactivate active_set_vector
\end{verbatim} 
\end{small}

The dakscilab executable results from compiling \texttt{dakscilab.c}
and has the following behavior and options.  The driver dakscilab
launches a server.  This server then facilitates communication between
Dakota and Scilab via named pipes communication. The user can also use
the first named pipe (\texttt{\$\{DAKSCILAB\_PIPE\}1}) to communicate
with the server:
\begin{small}
\begin{verbatim}
    echo dbg scilab_script.sce > ${DAKSCILAB_PIPE}1
    echo quit > ${DAKSCILAB_PIPE}1
\end{verbatim} 
\end{small}
The first command, with the keyword 'dbg', launches the script
scilab\_script.sci for evaluation in Scilab.  It permits to give
instructions to Scilab. The second command 'quit' stops the server.

The dakscilab shim supports the following options for the driver call:
\begin{enumerate}
  \item -s  to start the server
  \item -si to run an init script
  \item -sf to run a final script
  \item -f -fp -fpp to specify names of objective function, gradient
    and hessian, then load them.
\end{enumerate}

For the included PID example, the driver call is 
\begin{small}
\begin{verbatim}
    analysis_driver = '../dakscilab -d -si "exec init_test_automatic.sce;"
                     -sf "exec visualize_solution.sce;" -f "exec f_pid.sci"'
\end{verbatim}
\end{small}

Here there is an initialization script
(\texttt{init\_test\_automatic.sce;}) which is launched before the
main computation.  It initializes a specific Scilab module called
xcos. A finalization script to visualize the xcos solution is also
specified (\texttt{visualize\_solution.sce}). Finally, the objective
function is given with the computation code called
\texttt{f\_pid.sci}.


% LocalWords:  Scilab Yann Collette Chapalain Rosenbrock subdirectory dakota bb
% LocalWords:  scilab rosenbrock rosen argv pre PID FemTRUSS workspace mlist 1i
% LocalWords:  Matlab src ScilabInterface BOOL README dakscilab Hessians dbg si
% LocalWords:  init fp fpp sce xcos pid
