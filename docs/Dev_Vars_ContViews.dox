namespace Dakota {

/** \page VarContainersViews Working with Variable Containers and Views

\htmlonly
<b>Working with Variable Containers and Views Table of Contents</b>
<ul>
<li> <a href="VarContainersViews.html#VarStorage">Storage in Variables and SharedVariablesData</a> 
<li> <a href="VarContainersViews.html#VarActiveInactive">Active and inactive views</a> 
</ul>
\endhtmlonly

Different subsets of the total problem variables may be active in
different algorithm contexts, for example, in optimization under
uncertainty, where design variables are active in the optimization
portion, but the uncertain variables are active in the nested UQ
algorithm.  For efficiency, contiguous arrays of data store variable
information, but active and inactive views into them permit selecting
subsets in a given context.  This management is encapsulated into the
Variables and SharedVariablesData classes.  This page clarifies
concepts of merged vs. mixed, fine-grained vs. aggregated types,
domain types, and views into contiguous arrays.

\section VarStorage Storage in Variables and SharedVariablesData

This section describes the storage of variable values and meta-data
about their organization, used in part to manage views.  It is
intended to communicate rationale to maintainers of Variables and
SharedVariablesData.

The core data for a Variables instance is stored in a set of three
continguous arrays, corresponding to the domain types: 
\ref Dakota::Variables::allContinuousVars "allContinuousVars", 
\ref Dakota::Variables::allDiscreteIntVars "allDiscreteIntVars", and
\ref Dakota::Variables::allDiscreteRealVars "allDiscreteRealVars", unique
to each Variables instance, together with a SharedVariablesData
reference-counted object which stores information on the variables
configuration and may be shared among Variables instances.  The shared
data also include labels, which are often the same across many
Variables instances.

Within the core variable data arrays, data corresponding to different
aggregated variable types are stored in sequence for each domain type:
<ul>
  <li> continuous: [design, aleatory uncertain, epistemic uncertain, state]</li>
  <li> discrete integer: [design, aleatory uncertain, (epistemic uncertain), state]</li>
  <li> discrete real: [design, aleatory uncertain, (epistemic uncertain), state]</li>
</ul>
Note there are currently no epistemic discrete integer or real
variables.  This domain type ordering (continuous, discrete integer,
discrete real) and aggregated variable type ordering (design, aleatory
uncertain, epistemic uncertain, state) is preserved whenever distinct
types are flattened into single contiguous arrays.

In addition to storing common data, the SharedVariablesData class
maintains mappings between variable types, IDs, and indices into the
storage arrays.  Variable "types" refer to the fine-grained variable
types a user would specify, enumerated in DataVariables.H, e.g,
CONTINUOUS_DESIGN, WEIBULL_UNCERTAIN, or DISCRETE_STATE_RANGE.
\ref Dakota::SharedVariablesDataRep::variablesComponents "variablesComponents" 
is a map from these variable types to counts of how many are present.

In contrast, the 
\ref Dakota::SharedVariablesDataRep::variablesCompsTotals "variablesCompsTotals" 

array stores total counts of each "aggregated type" (design, aleatory
uncertain, epistemic uncertain, state) which might be selected to be
active in a given view.  Thus this array has length 12 to track the
combinations of three domain type storage arrays with four possible
aggregated variable types: {continuous, discrete integer, discrete
real} x {design, aleatory uncertain, epistemic uncertain, state}.  For
example the first entry of this array stores the number of continuous
design variables, the second the number of discrete integer design
(including both discrete design range and discrete design set integer
types), and the last the number of discrete real state variables.

The arrays 
\ref Dakota::SharedVariablesDataRep::allContinuousTypes "allContinuousTypes", 
\ref Dakota::SharedVariablesDataRep::allDiscreteIntTypes "allDiscreteIntTypes", and
\ref Dakota::SharedVariablesDataRep::allDiscreteRealTypes "allDiscreteRealTypes"
are sized to match the corresponding core domain type storage arrays.
They track the fine-grained variable type stored in that entry of the
data array (since when relaxed, the continuous array may be storing
data corresponding to discrete data).

Finally 
\ref Dakota::SharedVariablesDataRep::allContinuousIds "allContinuousIds"
stores the 1-based IDs of the variables stored in the
allContinuousVars array, i.e., the variable number of all the problem
variables considered as a single contiguous set, in aggregate type
order.  For merged (relaxed) views,
\ref Dakota::SharedVariablesDataRep::mergedDiscreteIds "mergedDiscreteIds"
stores the 1-based IDs of the variables which have been relaxed into
the continuous array.

\section VarActiveInactive Active and inactive views

As noted in the main page, a MergedVariables object combines
continuous and discrete types (relaxing integers to reals) whereas a
MixedVariables object maintains the integer/real distinction
throughout.  When relaxing, the continuous variable and labels arrays
potentially contain ALL design, then ALL uncertain, then ALL state
variables, each in aggregated type order.

The pair \ref Dakota::SharedVariablesDataRep::variablesView "variablesView"
tracks the active and inactive views of the data, with values taken
from the enum in DataVariables.H The valid values include EMPTY and
the combinations {merged, mixed} x {all, design, aleatory uncertain,
epistemic uncertain, all uncertain, state}.  TODO: Document what
DISTINCT means in the enum.  The view is determined by the algorithm
in use.  The method-dependent logic for setting the active and
inactive views is in 
\ref Variables::get_view "Variables::get_view()".

Given these groupings (views), the active subsets of the variables
arrays are always contiguous, permitting vector views of the
underlying data. This happens upon construction of the Variables
objects, so subsequent active and inactive queries on a Variables
object retrieve the appropriate contiguous view of the data.

When a Variables envelope is constructed, its letter is initialized to
either a MergedVariables or MixedVariables object depending on the
active view.  The derived classes size the contiguous storage arrays
to accomodate all the problem variables, and then initialize active
and inactive views into them.  Thus a later query for active
continuous variables might return contnuous all or a subset such as
design, uncertain, only aleatory, etc., as described above.

TODO: Discuss difference between active, inactive, and active
complement in nested contexts.

*/

} // namespace Dakota
