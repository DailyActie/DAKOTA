## DAKOTA INPUT FILE - dakota_rosenbrock_2d.in #0
## DAKOTA INPUT FILE - dakota_rosenbrock_vector.in #1
## DAKOTA INPUT FILE - dakota_rosenbrock_grad_opt.in #2
## DAKOTA INPUT FILE - dakota_rosenbrock_ps_opt.in #4
## DAKOTA INPUT FILE - dakota_rosenbrock_ea_opt.in #5
## DAKOTA INPUT FILE - dakota_rosenbrock_nond.in #6
## DAKOTA INPUT FILE - dakota_rosenbrock_syscall.in #7
## DAKOTA INPUT FILE - dakota_rosenbrock_ls.in #8

# DAKOTA Users Manual Ch 2 example problems using Rosenbrock's function
#   test 0 = dakota_rosenbrock_2d.in
#   test 1 = dakota_rosenbrock_vector.in
#   test 2 = dakota_rosenbrock_grad_opt.in
#   test 3 = former dakota_rosenbrock_ls.in
#   test 4 = dakota_rosenbrock_ps_opt.in
#   test 5 = dakota_rosenbrock_ea_opt.in
#   test 6 = dakota_rosenbrock_nond.in
#   test 7 = dakota_rosenbrock_syscall.in
#   test 8 = dakota_rosenbrock_ls.in
#   test 9 = dakota_rosenbrock_scaled.in

strategy,
	single_method
	  graphics,tabular_graphics_data

method,
	multidim_parameter_study		#0
	  partitions = 8 8			#0
#	vector_parameter_study			#1
#	  final_point = 1.1  1.3 		#1
#	  num_steps = 10			#1
#	conmin_frcg				#2,#7,#9
#	  scaling				#9
#	  output verbose			#9
#	optpp_g_newton                    	#3
#	nl2sol					#8
#	  max_iterations = 100			#2,#3,#7,#8
#	  convergence_tolerance = 1e-4		#2,#3,#7,#8
#	coliny_pattern_search                   #4
#	  max_iterations = 1000			#4
#	  max_function_evaluations = 2000	#4
#	  solution_accuracy = 1e-4		#4
#	  initial_delta = 0.5			#4
#	  threshold_delta = 1e-4		#4
#	  exploratory_moves basic_pattern	#4
#	  contraction_factor = 0.75		#4
#	coliny_ea				#5
#	  max_iterations = 100			#5
#	  max_function_evaluations = 2000	#5
#	  seed = 11011011			#5
#	  population_size = 50			#5
#	  fitness_type merit_function		#5
#	  mutation_type offset_normal		#5
#	  mutation_rate 1.0			#5
#	  crossover_type two_point		#5
#	  crossover_rate 0.0			#5
#	  replacement_type chc = 10		#5
#	nond_sampling				#6
#	  samples = 200	seed = 17		#6
#	  sample_type random			#6
#	  response_levels = 100.0		#6

model,
	single

variables,
	continuous_design = 2			#0,#1,#2,#3,#4,#5,#7,#8,#9
#	  initial_point   -0.3      0.2	#1
#	  initial_point   -1.2	1.0	#2,#3,#7,#8,#9
#	  initial_point    0.0	0.0	#4
	  lower_bounds    -2.0     -2.0	#0,#2,#3,#4,#5,#7,#8
#	  lower_bounds    -2.0      0.001	#9
	  upper_bounds     2.0      2.0	#0,#2,#3,#4,#5,#7,#8,#9
	  descriptors      'x1'     "x2"	#0,#1,#2,#3,#4,#5,#7,#8,#9
#	  cdv_scale_types = 'value' 'log'	#9
#	  cdv_scales = 4.0 0.1			#9
#	uniform_uncertain = 2			#6
#	  lower_bounds -2.0  -2.0	#6
#	  upper_bounds  2.0   2.0	#6
#	  descriptors        'x1'  'x2'	#6

interface,
#	fork asynch
	direct					#0,#1,#2,#3,#4,#5,#6,#8,#9
#	system					#7
	  analysis_driver = 'rosenbrock'
#	  parameters_file = 'params.in'		#7
#	  results_file    = 'results.out'	#7

responses,
	num_objective_functions = 1             #0,#1,#2,#4,#5,#7,#9
#	  objective_function_scale_types = 'value' #9
#	  objective_function_scales = 50.0	#9
#	num_least_squares_terms = 2		#3,#8
#	num_response_functions = 1		#6
	no_gradients				#0,#1,#4,#5,#6
##	analytic_gradients			#2
#	numerical_gradients			#2,#7
#	  method_source dakota			#2,#7
#	  interval_type forward			#2,#7
#	  fd_gradient_step_size = 1.e-5		#2,#7
#	analytic_gradients			#3,#8,#9
	no_hessians
