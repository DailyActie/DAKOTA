#@ p0: MPIProcs=4
#@ p1: MPIProcs=4
#@ p2: MPIProcs=4
#@ p3: MPIProcs=5
#@ p4: MPIProcs=5
# DAKOTA INPUT FILE : dakota_dace.in

# Each DAKOTA test file is capable of running multiple tests. The
# manual process for doing this is to add or uncomment specific lines
# needed for a test and comment out other lines which are not needed
# for that specific test.  Within the automatic test script, a special
# syntax is used to automatically determine which lines are to be used
# for a specific test. A #n (0 - 9) is used to associate lines in the
# test file with a specific test.  The test 0 marker designates lines
# which are to be run as part of the baseline test but not part of the
# other tests. To add multiple tests to a file add the #n to the
# trailing comment of a line, the dakota_test script will parse
# through the file uncommenting the lines marked for a specific test,
# and commenting out unneeded lines marked with the test 0 marker.
# Specific lines can be included in multiple tests by adding multiple
# #n designators separated by a comma.

# Processor specification for automated parallel tests:
# p0=4, p1=4, p2=4, p3=5, p4=5

environment,
	  graphics
	  tabular_graphics_data

method,
	dace oas seed = 5		#s0,#s8,#p0,#p1,#p2,#p3,#p4
#       dace oa_lhs seed = 5            #s9
	  samples = 49 symbols = 7 	#s0,#s8,#s9,#p0,#p1,#p2,#p3,#p4
#	dace lhs seed = 5		#s1
#	  samples = 50 symbols = 50	#s1
#	fsu_quasi_mc hammersley		#s2,#s3
#	fsu_quasi_mc halton		#s4,#s5
#	fsu_cvt				#s6,#s7
#	  samples = 100			#s2,#s3,#s4,#s5,#s6,#s7
#	  latinize			#s3,#s5,#s7
	  quality_metrics		#s0,#s3,#s5,#s7
#	  sequence_start 0 0 0 0	#s2,#s3,#s4,#s5
#	  sequence_leap  1 1 1 1	#s2,#s3,#s4,#s5
#	  prime_base   3 5 7		#s2
#	  prime_base 2 3 5 7  		#s4
#  	  seed = 50374 fixed_seed	#s6,#s7
#	  num_trials = 10000		#s6,#s7
#	  max_iterations = 100		#s6,#s7
#	  output quiet	   		#s1,#s2,#s3,#s4,#s5,#s6,#s7,#s8,#s9,#p0,#p1,#p2,#p3,#p4

variables,
	active all
	continuous_design = 3
	  initial_point       1.0 1.0 1.0
	  lower_bounds        0.0 0.0 0.0
	  upper_bounds        2.0 2.0 2.0
	continuous_state = 1
	  initial_state       4.0
	  lower_bounds        0.0
	  upper_bounds        8.0
#	discrete_design_set			#s8
#         integer = 2				#s8
#	    num_set_values = 4 5	      	#s8
#	    set_values = -4 -3 -2 -1 0 1 2 3 4	#s8

interface,
	id_interface = 'I1'
#	evaluation_scheduling master
# Force following line as comment in test 0 for examples/advanced
#	evaluation_scheduling master	    	#s0
#	evaluation_scheduling peer dynamic	#p1,#p4
#	evaluation_servers = 4	   		#p4
#	processors_per_evaluation = 1		#p4
	system
	  asynchronous			#s0,#s1,#s2,#s3,#s4,#s5,#s6,#s7,#s8,#s9,#p2,#p3
	    evaluation_concurrency = 5	#s0,#s1,#s2,#s3,#s4,#s5,#s6,#s7,#s8,#s9,#p2
#	    evaluation_concurrency = 10	#p3
	  analysis_driver = 'text_book'

responses,
	objective_functions = 1
	nonlinear_inequality_constraints = 2
	no_gradients
	no_hessians
